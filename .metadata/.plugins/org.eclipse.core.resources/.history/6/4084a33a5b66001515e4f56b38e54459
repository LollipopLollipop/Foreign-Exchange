import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.StringTokenizer;

/**
 * 
 * @author ding
 * Main workflow of HW2: 
 * read 10000 prep-ed data instances
 * randomize into training and testing set
 * grow the decision tree based on training set
 * classify testing set and analyze predicted result
 */

public class HW2 {
	private static final int TOTAL_INSTANCES = 10000;
	public static void main(String[] args) {
		try {
			//use buffered reader and writer for fast IO
			BufferedReader br = new BufferedReader(new FileReader(args[0]));
			BufferedWriter bw = new BufferedWriter(new FileWriter(args[1]));
			//read 10K instances
			String thisLine = null;
			ArrayList<CandleStick> totalInstances = new ArrayList<CandleStick>();
			int count = 0;
			while ((thisLine = br.readLine()) != null && count<TOTAL_INSTANCES) {
				StringTokenizer featureTokenizer = new StringTokenizer(thisLine, ",");
				String[] featuresNLabel = new String[6];
				int i=0;
				while(featureTokenizer.hasMoreTokens()){
					featuresNLabel[i++] = featureTokenizer.nextToken();
				}
				//wrap each record into CandleStick obj
				CandleStick cs = new CandleStick(featuresNLabel);
				totalInstances.add(cs);
				count ++;
			}
			Collections.shuffle(totalInstances);
			ArrayList<CandleStick> testingInstances = 
					new ArrayList<CandleStick>(totalInstances.subList(0, 2000));
			ArrayList<CandleStick> trainingInstances = 
					new ArrayList<CandleStick>(totalInstances.subList(2000, 10000));
			
			System.out.println(trainingInstances.size());
			DecisionTree dt = new DecisionTree(trainingInstances);
			//build the tree
			dt.train();
			//dt.printAll();
			System.out.println(testingInstances.size());
			ArrayList<Integer> predictedLabels = dt.classify(testingInstances);
			System.out.println("predicted size "+ predictedLabels.size());
			int matchCount = 0;
			for(int i=0; i<2000; i++){
				StringBuilder sb = new StringBuilder();
				sb.append("label: ");
				sb.append(testingInstances.get(i).getLabel());
				sb.append("\t");
				sb.append("predicted: ");
				sb.append(predictedLabels.get(i));
				sb.append("\n");
				bw.write(sb.toString());
				try{
				if(testingInstances.get(i).getLabel()==predictedLabels.get(i))
					matchCount++;
				}catch(Exception e){
					System.out.println("current i is " + i);
					e.printStackTrace();
				}
			}
			bw.write(matchCount+" out of 2000 predicted correctly. prob=" + (double)matchCount/2000 + "\n");
			br.close();
			bw.flush();
			bw.close();
			
		} catch (FileNotFoundException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
	}
	
	
//	public static int NUM_ATTRS = 6;
//	public static ArrayList<String> attrMap;
//	public static ArrayList<Integer> usedAttributes = new ArrayList<Integer>();
//
//	public static void main(String[] args) {
//		populateAttrMap();
//
//		Tree t = new Tree();
//		ArrayList<Record> records;
//		LearningSet learningSet = new LearningSet();
//		
//		// read in all our data
//		records = FileReader.buildRecords();
//		
//		Node root = new Node();
//		
//		for(Record record : records) {
//			root.getData().add(record);
//		}
//		
//		t.buildTree(records, root, learningSet);
//		traverseTree(records.get(12), root);
//		return;
//	}
//	
//	public static void traverseTree(Record r, Node root) {
//		while(root.children != null) {
//			double nodeValue = 0;
//			for(int i = 0; i < r.getAttributes().size(); i++) {
//				if(r.getAttributes().get(i).getName().equalsIgnoreCase(root.getTestAttribute().getName())) {
//					nodeValue = r.getAttributes().get(i).getValue();
//					break;
//				}
//			}
//			for(int i = 0; i < root.getChildren().length; i++) {
//				if(nodeValue == root.children[i].getTestAttribute().getValue()) {
//					traverseTree(r, root.children[i]);
//				}
//			}
//		}
//		
//		System.out.print("Prediction for Play Tennis: ");
//		if(root.getTestAttribute().getValue() == 0) {
//			System.out.println("No");
//		}
//		else if(root.getTestAttribute().getValue() == 0) {
//			System.out.println("Yes");
//		}
//
//		return;
//	}
//	
//	public static boolean isAttributeUsed(int attribute) {
//		if(usedAttributes.contains(attribute)) {
//			return true;
//		}
//		else {
//			return false;
//		}
//	}
//	
//	public static int setSize(String set) {
//		if(set.equalsIgnoreCase("Outlook")) {
//			return 3;
//		}
//		else if(set.equalsIgnoreCase("Wind")) {
//			return 2;
//		}
//		else if(set.equalsIgnoreCase("Temperature")) {
//			return 3;
//		}
//		else if(set.equalsIgnoreCase("Humidity")) {
//			return 2;
//		}
//		else if(set.equalsIgnoreCase("PlayTennis")) {
//			return 2;
//		}
//		return 0;
//	}
//	
//	public static String getLeafNames(int attributeNum, int valueNum) {
//		if(attributeNum == 0) {
//			if(valueNum == 0) {
//				return "Sunny";
//			}
//			else if(valueNum == 1) {
//				return "Overcast";
//			}
//			else if(valueNum == 2) {
//				return "Rain";
//			}
//		}
//		else if(attributeNum == 1) {
//			if(valueNum == 0) {
//				return "Hot";
//			}
//			else if(valueNum == 1) {
//				return "Mild";
//			}
//			else if(valueNum == 2) {
//				return "Cool";
//			}
//		}
//		else if(attributeNum == 2) {
//			if(valueNum == 0) {
//				return "High";
//			}
//			else if(valueNum == 1) {
//				return "Normal";
//			}
//		}
//		else if(attributeNum == 3) {
//			if(valueNum == 0) {
//				return "Weak";
//			}
//			else if(valueNum == 1) {
//				return "Strong";
//			}
//		}
//		
//		return null;
//	}
//	
//	public static void populateAttrMap() {
//		attrMap = new ArrayList<String>();
//		attrMap.add("Outlook");
//		attrMap.add("Temperature");
//		attrMap.add("Humidity");
//		attrMap.add("Wind");
//		attrMap.add("PlayTennis");
//	}
}
