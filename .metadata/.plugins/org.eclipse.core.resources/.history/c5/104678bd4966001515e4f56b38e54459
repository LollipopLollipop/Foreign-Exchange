import java.io.*;
import java.util.*;

public class DecisionTree {
	private DTNode root = new DTNode();
	//private HashSet<String> attributes = new HashSet<String>();
	//4 features
	private boolean[] used = new boolean[4];
	
	public DecisionTree(ArrayList<CandleStick> allTrainingInstances){
		this.root.addInstances(allTrainingInstances);
		//this.attributes = new HashSet<String>(allTrainingInstances.get(0).getFeatures());
	}
	public void train(){
		buildDTree(this.root);
	}
	
	private DTNode buildDTree(DTNode curRoot){
		//leaf node
		if(curRoot.setEntropy()==0){
			return curRoot;
		System.out.println("cur root entropy " + curRoot.getEntropy());
		int bestAttr = -1;
		double bestIG = Double.MIN_VALUE;
		CandleStick thresholdInstance = new CandleStick();
		//ArrayList<CandleStick> instances = new ArrayList<CandleStick>(curRoot.getInstances());
		List<CandleStick> leftInstances = new ArrayList<CandleStick>();
		List<CandleStick> rightInstances = new ArrayList<CandleStick>();
		
		//loop through attributes to find the best split
		for(int i=0; i<4; i++){
			//skip if current attribute already used in upper level
//			if(used[i])
//				continue;
		
			if(i==0){
				curRoot.getInstances().sort(CandleStick.CandleStickTimeComparator);
				
//				ArrayList<String> vals = new ArrayList<String>();
//				for(CandleStick ins : curRoot.getInstances()){
//					vals.add((String)ins.getFeatureVal(attribute));
//				}
				
//				Collections.sort(vals);
//				String threshold = vals.get(vals.size()/2);
			}else if(i==1){
				curRoot.getInstances().sort(CandleStick.CandleStickHighPriceComparator);
			}else if(i==2){
				curRoot.getInstances().sort(CandleStick.CandleStickLowPriceComparator);
			}else if(i==3){
				curRoot.getInstances().sort(CandleStick.CandleStickClosePriceComparator);
			}
			
			for(int thresholdIdx = 1; thresholdIdx<curRoot.getInstancesSize()-1; thresholdIdx++){
				List<CandleStick> left =  new ArrayList<CandleStick>(
						curRoot.getInstances().subList(0, thresholdIdx));
				List<CandleStick> right =  new ArrayList<CandleStick>(
						curRoot.getInstances().subList(thresholdIdx, curRoot.getInstancesSize()));
	//			for(CandleStick ins : curRoot.getInstances()){
	//				if(belongToRight(i, ins, threshold))
	//					right.add(ins);
	//				else
	//					left.add(ins);
	//			}
				
				double leftEntropy = calcEntropy(left);
				//System.out.println("cur root left entropy " + leftEntropy);
				double rightEntropy = calcEntropy(right);
				//System.out.println("cur root right entropy " + rightEntropy);
				double infoGain = curRoot.getEntropy() - 
						((double)left.size()/curRoot.getInstancesSize())*leftEntropy - 
						((double)right.size()/curRoot.getInstancesSize())*rightEntropy;
				//System.out.println(infoGain);
				if(infoGain>bestIG){
					bestIG = infoGain;
					bestAttr = i;
					thresholdInstance = curRoot.getInstances().get(thresholdIdx);
					leftInstances = left;
					rightInstances = right;
				}
			}
		}
		
		if(bestAttr==-1){
			System.out.println("best attr is -1");
			System.out.println("cur node instances count" + curRoot.getInstancesSize());
			for(CandleStick cs:curRoot.getInstances()){
				System.out.println(cs.toString());
			}
			System.out.println("cur node left instances count" + leftInstances.size());
			return curRoot;
		}
		
		used[bestAttr] = true;
		curRoot.setTestCondition(bestAttr, thresholdInstance);
		DTNode leftBranch = new DTNode();
		leftBranch.addInstances(leftInstances);
		curRoot.left = leftBranch;
		DTNode rightBranch = new DTNode();
		rightBranch.addInstances(rightInstances);
		curRoot.right = rightBranch;
		//curRoot.setLeft(new DTNode());
		//curRoot.setRight(new DTNode());
		
		buildDTree(curRoot.left);
		buildDTree(curRoot.right);
		used[bestAttr] = false;
		return curRoot;
	}
	
	public void printAll(){
		inOrder(root);
	}
	
	private void inOrder(DTNode curRoot)
	{
	 
	  if(curRoot==null) return;
	  
	  inOrder(curRoot.getLeft());
	  
	  curRoot.print();
	  
	  inOrder(curRoot.getRight()); 
	  
	}
	
//	private boolean belongToRight(String attribute, CandleStick ins,
//			CandleStick threshold) {
//		if(attribute.equals("time")){
//			if(ins.getTime().compareTo(threshold.getTime())>=0)
//				return true;
//			else
//				return false;
//		}else{
//			if(ins.getPrice(attribute)>=threshold.getPrice(attribute))
//				return true;
//			else
//				return false;
//		}
//		
//	}

	public class DTNode{
		private List<CandleStick> instances = new ArrayList<CandleStick>();
		private double entropy;
		private DTNode left;
		private DTNode right;
		private int testCond;
		private CandleStick thresholdIns;
		
		public DTNode(){
			
		}
		public int getInstancesSize() {
			// TODO Auto-generated method stub
			return this.instances.size();
		}
		public List<CandleStick> getInstances() {
			// TODO Auto-generated method stub
			return this.instances;
		}
		private void addInstances(List<CandleStick> instances){
			this.instances = instances;
		}
		private double setEntropy(){
			this.entropy = calcEntropy(this.instances);
			return this.entropy;
		}
		private double getEntropy(){
			return this.entropy;
		}
		private void setLeft(DTNode n){
			this.left = n;
		}
		private void setRight(DTNode n){
			this.right = n;
		}
		private DTNode getLeft(){
			return this.left;
		}
		private DTNode getRight(){
			return this.right;
		}
		private void setTestCondition(int c, CandleStick thresholdInstance){
			System.out.println("set test cond on attribute on " + c + " with threshold instance as " +
					thresholdInstance.toString());
			this.testCond = c;
			this.thresholdIns = thresholdInstance;
		}
		public void print(){
			System.out.println("test cond " + 
					this.testCond + " with " + instances.size() 
					+ " instances");
		}
	}
	
	private double calcEntropy(List<CandleStick> sampleInstances){
		int n = sampleInstances.size();
		int riseCount = 0;
		int dropCount = 0;
		int constantCount = 0;
		for(CandleStick instance : sampleInstances){
			if(instance.getLabel()==1)
				riseCount++;
			else if(instance.getLabel()==-1)
				dropCount++;
			else
				constantCount++;
		}
		double riseProb = ((double)riseCount)/n;
		double dropProb = ((double)dropCount)/n;
		double constantProb = ((double)constantCount)/n;
		Double entropy = 0.0;
		if(riseProb!=0)
			entropy -= riseProb*Math.log(riseProb);
		if(dropProb!=0)
			entropy -= dropProb*Math.log(dropProb);
		if(constantProb!=0)
			entropy -= constantProb*Math.log(constantProb);
		
		return entropy;
	}
	
	public ArrayList<Integer> classify(ArrayList<CandleStick> testingInstances) {
		ArrayList<Integer> predictedLabels = new ArrayList<Integer>();
		for(CandleStick cs: testingInstances){
			int predictedLabel = findMatch(this.root, cs);
			//System.out.println("label returned to res is "+predictedLabel);
			predictedLabels.add(predictedLabel);
		}
		return predictedLabels;
	}
	
	private Integer findMatch(DTNode curRoot, CandleStick cs) {
		if(curRoot.entropy==0 || (curRoot.left==null&&curRoot.right==null)){
			//System.out.println("find match predicted label as " + 
					//curRoot.getInstances().get(0).getLabel());
			return curRoot.getInstances().get(0).getLabel();
		}
		else{
			if(inLeftBranch(curRoot, cs)){
				return findMatch(curRoot.left, cs);
			}else{
				return findMatch(curRoot.right, cs);
			}
				
		}
	}
	
	private boolean inLeftBranch(DTNode curRoot, CandleStick cs) {
		CandleStick toCmp = curRoot.thresholdIns;
		int testCondition = curRoot.testCond;
		if(cs.compareWith(toCmp, testCondition)<0){
			return true;
		}else{
			return false;
		}
	}

	
//	public Node buildTree(ArrayList<Record> records, Node root, LearningSet learningSet) {
//		int bestAttribute = -1;
//		double bestGain = 0;
//		root.setEntropy(Entropy.calculateEntropy(root.getData()));
//		
//		if(root.getEntropy() == 0) {
//			return root;
//		}
//		
//		for(int i = 0; i < Hw1.NUM_ATTRS - 2; i++) {
//			if(!Hw1.isAttributeUsed(i)) {
//				double entropy = 0;
//				ArrayList<Double> entropies = new ArrayList<Double>();
//				ArrayList<Integer> setSizes = new ArrayList<Integer>();
//				
//				for(int j = 0; j < Hw1.NUM_ATTRS - 2; j++) {
//					ArrayList<Record> subset = subset(root, i, j);
//					setSizes.add(subset.size());
//					
//					if(subset.size() != 0) {
//						entropy = Entropy.calculateEntropy(subset);
//						entropies.add(entropy);
//					}
//				}
//				
//				double gain = Entropy.calculateGain(root.getEntropy(), entropies, setSizes, root.getData().size());
//				
//				if(gain > bestGain) {
//					bestAttribute = i;
//					bestGain = gain;
//				}
//			}
//		}
	
//		if(bestAttribute != -1) {
//			int setSize = Hw1.setSize(Hw1.attrMap.get(bestAttribute));
//			root.setTestAttribute(new DiscreteAttribute(Hw1.attrMap.get(bestAttribute), 0));
//			root.children = new Node[setSize];
//			root.setUsed(true);
//			Hw1.usedAttributes.add(bestAttribute);
//			
//			for (int j = 0; j< setSize; j++) {
//				root.children[j] = new Node();
//				root.children[j].setParent(root);
//				root.children[j].setData(subset(root, bestAttribute, j));
//				root.children[j].getTestAttribute().setName(Hw1.getLeafNames(bestAttribute, j));
//				root.children[j].getTestAttribute().setValue(j);
//			}
//
//			for (int j = 0; j < setSize; j++) {
//				buildTree(root.children[j].getData(), root.children[j], learningSet);
//			}
//
//			root.setData(null);
//		}
//		else {
//			return root;
//		}
//		
//		return root;
//	}
//	
//	public ArrayList<Record> subset(Node root, int attr, int value) {
//		ArrayList<Record> subset = new ArrayList<Record>();
//		
//		for(int i = 0; i < root.getData().size(); i++) {
//			Record record = root.getData().get(i);
//			
//			if(record.getAttributes().get(attr).getValue() == value) {
//				subset.add(record);
//			}
//		}
//		return subset;
//	}
//	
//	public double calculateSurrogates(ArrayList<Record> records) {
//		return 0;
//	}
}
